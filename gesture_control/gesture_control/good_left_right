#!/usr/bin/env python3
import os
import sys
import yaml
import logging
import cv2
import rclpy
from rclpy.node import Node
from rclpy.time import Time
from cv_bridge import CvBridge
from sensor_msgs.msg import Image
from geometry_msgs.msg import TwistStamped
from mavros_msgs.srv import CommandBool, CommandTOL
from mavros_msgs.msg import State

from addict import Dict
from ament_index_python.packages import get_package_share_directory

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger('gesture_node')

def get_cfg() -> Dict:
    pkg_share = get_package_share_directory('gesture_control')
    config_path = os.path.join(pkg_share, 'params', 'params.yaml')
    with open(config_path, 'rb') as f:
        raw = yaml.load(f, Loader=yaml.FullLoader)
    return Dict(raw['gesture_classifier'])

class GestureNode(Node):
    def __init__(self):
        super().__init__('gesture_node')
        self.cfg = get_cfg()
        
        # –î–æ–±–∞–≤–∏–º –ø—É—Ç—å –∫ —Å–∫—Ä–∏–ø—Ç—É
        script_dir = os.path.dirname(self.cfg.script_path)
        if script_dir not in sys.path:
            sys.path.insert(0, script_dir)

        # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∏ —Å–æ–∑–¥–∞—ë–º –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä
        from app_for_ros2 import GestureClassifier
        self.classifier = GestureClassifier(self.cfg)

        self.bridge = CvBridge()
        self.current_command = (0.0, 0.0, 0.05, 0.0)  # x, y, z, yaw; z=0.05 –¥–ª—è —É–¥–µ—Ä–∂–∞–Ω–∏—è –≤—ã—Å–æ—Ç—ã
        self.current_state = State()
        self.offboard_attempts = 0
        self.max_offboard_attempts = 5
        self.disarm_count = 0
        self.disarm_threshold = 15  # –¢—Ä–µ–±—É–µ—Ç—Å—è 15 –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–π Disarm
        self.move_start_time = None  # –í—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ –¥–≤–∏–∂–µ–Ω–∏—è (rclpy.time.Time)
        self.move_duration = 0.0  # –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
        self.last_move_gesture = None  # –ü–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π move_gesture
        self.move_gesture_count = 0  # –°—á—ë—Ç—á–∏–∫ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–π
        self.move_gesture_threshold = 3  # –¢—Ä–µ–±—É–µ—Ç—Å—è 3 –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –¥–ª—è —Ñ–∏–∫—Å–∞—Ü–∏–∏

        # –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥—Ä–æ–Ω–∞
        self.state_sub = self.create_subscription(
            State,
            '/mavros/state',
            self.state_callback,
            10
        )

        self.image_sub = self.create_subscription(
            Image,
            self.cfg.topic.image_input,
            self.image_callback,
            10
        )

        self.cmd_vel_pub = self.create_publisher(
            TwistStamped,
            self.cfg.topic.cmd_vel_output,
            10
        )

        self.arm_client = self.create_client(CommandBool, self.cfg.topic.arming_srv)
        while not self.arm_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info(' –û–∂–∏–¥–∞–Ω–∏–µ MAVROS /cmd/arming...')

        from mavros_msgs.srv import SetMode
        self.set_mode_client = self.create_client(SetMode, '/mavros/set_mode')
        while not self.set_mode_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info(' –û–∂–∏–¥–∞–Ω–∏–µ MAVROS /set_mode...')

        self.takeoff_client = self.create_client(CommandTOL, '/mavros/cmd/takeoff')
        while not self.takeoff_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info(' –û–∂–∏–¥–∞–Ω–∏–µ MAVROS /cmd/takeoff...')

        self.gesture_commands = {
            'Up':       (0.0, 0.0, 1.0, 0.0),
            'Down':     (0.0, 0.0, -1.0, 0.0),
            'Left':     (0.0, 1.0, 0.0, 0.0),
            'Right':    (0.0, -1.0, 0.0, 0.0),
            'Forward':  (1.0, 0.0, 0.0, 0.0),
            'Backward': (-1.0, 0.0, 0.0, 0.0),
        }

        self.move_gesture_command = {
            'LEFT': (0.0, 1.0, 0.0, 0.0),
            'RIGHT': (0.0, -1.0, 0.0, 0.0),
            'FORWARD': (1.0, 0.0, 0.0, 0.0),
            'BACKWARD': (-1.0, 0.0, 0.0, 0.0),
        }

        self.speed = self.cfg.get('speed', 0.5)
        self.distance = 5.0  # –¶–µ–ª–µ–≤–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –ª–∏–Ω–µ–π–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è (–º)
        self.linear_move_duration = self.distance / self.speed  # –í—Ä–µ–º—è –¥–ª—è 5 –º

        # –¢–∞–π–º–µ—Ä –¥–ª—è –∫–æ–º–∞–Ω–¥ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–µ–∂–∏–º–∞ (20 –ì—Ü)
        self.timer = self.create_timer(0.05, self.timer_callback)

        self.get_logger().info(f' GestureNode –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω, –ø–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ {self.cfg.topic.image_input}')

    def state_callback(self, msg):
        self.current_state = msg
        self.get_logger().info(f'–¢–µ–∫—É—â–∏–π —Ä–µ–∂–∏–º: {self.current_state.mode}, Armed: {self.current_state.armed}')

    def set_mode(self, mode_name: str):
        from mavros_msgs.srv import SetMode
        req = SetMode.Request()
        req.custom_mode = mode_name
        future = self.set_mode_client.call_async(req)
        self.get_logger().info(f'–ü–æ–ø—ã—Ç–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ä–µ–∂–∏–º {mode_name}')
        future.add_done_callback(lambda f: self.mode_response_cb(f, mode_name))

    def mode_response_cb(self, future, mode_name):
        try:
            result = future.result()
            if result.mode_sent:
                self.get_logger().info(f'‚úÖ –†–µ–∂–∏–º {mode_name} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω')
                if mode_name == 'OFFBOARD':
                    self.offboard_attempts = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ –ø–æ–ø—ã—Ç–æ–∫
            else:
                self.get_logger().warn(f'‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ä–µ–∂–∏–º {mode_name}')
                if mode_name == 'OFFBOARD' and self.offboard_attempts < self.max_offboard_attempts:
                    self.offboard_attempts += 1
                    self.get_logger().info(f'–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å OFFBOARD ({self.offboard_attempts}/{self.max_offboard_attempts})')
                    self.set_mode('OFFBOARD')
        except Exception as e:
            self.get_logger().error(f'‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ —Ä–µ–∂–∏–º–∞ {mode_name}: {e}')

    def timer_callback(self):
        x, y, z, yaw = self.current_command
        twist = TwistStamped()
        twist.header.stamp = self.get_clock().now().to_msg()
        twist.header.frame_id = 'base_link'
        twist.twist.linear.x = x
        twist.twist.linear.y = y
        twist.twist.linear.z = z
        twist.twist.angular.z = yaw
        self.cmd_vel_pub.publish(twist)
        self.get_logger().debug(f'–ö–æ–º–∞–Ω–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞: x={x}, y={y}, z={z}, yaw={yaw}')

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å–ª–∏ –¥—Ä–æ–Ω –≤ —Ä–µ–∂–∏–º–µ AUTO.LOITER –ø–æ—Å–ª–µ –∞—Ä–º–∏–Ω–≥–∞
        if self.current_state.armed and self.current_state.mode != 'OFFBOARD' and self.offboard_attempts < self.max_offboard_attempts:
            self.get_logger().info(f'–î—Ä–æ–Ω –≤ —Ä–µ–∂–∏–º–µ {self.current_state.mode}, –ø–æ–ø—ã—Ç–∫–∞ –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –≤ OFFBOARD')
            self.set_mode('OFFBOARD')

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–≤–µ—Ä—à–µ–Ω–æ –ª–∏ –¥–≤–∏–∂–µ–Ω–∏–µ –¥–ª—è Pointer
        if self.move_start_time is not None:
            elapsed = (self.get_clock().now() - self.move_start_time).nanoseconds * 1e-9
            if elapsed >= self.move_duration:
                self.get_logger().info('–î–≤–∏–∂–µ–Ω–∏–µ Pointer –∑–∞–≤–µ—Ä—à–µ–Ω–æ')
                self.current_command = (0.0, 0.0, 0.05, 0.0)  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —É–¥–µ—Ä–∂–∞–Ω–∏—é –≤—ã—Å–æ—Ç—ã
                self.move_start_time = None
                self.move_duration = 0.0
                self.last_move_gesture = None
                self.move_gesture_count = 0

    def arm_response_cb(self, future):
        try:
            result = future.result()
            if result.success:
                self.get_logger().info('üõ©Ô∏è Arm —É—Å–ø–µ—à–µ–Ω')
                # –ù–∞—á–∏–Ω–∞–µ–º –ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã —Å–∫–æ—Ä–æ—Å—Ç–∏ –¥–ª—è OFFBOARD
                self.current_command = (0.0, 0.0, 0.05, 0.0)  # z=0.05 –¥–ª—è —É–¥–µ—Ä–∂–∞–Ω–∏—è –≤—ã—Å–æ—Ç—ã
                # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–µ–∂–∏–º OFFBOARD
                self.set_mode('OFFBOARD')
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –Ω–∞ –≤–∑–ª—ë—Ç
                self.send_takeoff_command()
            else:
                self.get_logger().warn(f'‚ö†Ô∏è Arm –æ—Ç–∫–∞–∑: result={result.result}')
        except Exception as e:
            self.get_logger().error(f'‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ Arm: {e}')

    def disarm_response_cb(self, future):
        try:
            result = future.result()
            if result.success:
                self.get_logger().info('üõ¨ Disarm —É—Å–ø–µ—à–µ–Ω')
                self.disarm_count = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫
            else:
                self.get_logger().warn(f'‚ö†Ô∏è Disarm –æ—Ç–∫–∞–∑: result={result.result}')
        except Exception as e:
            self.get_logger().error(f'‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ Disarm: {e}')

    def send_takeoff_command(self):
        req = CommandTOL.Request()
        req.altitude = 2.0  # –í—ã—Å–æ—Ç–∞ –≤–∑–ª—ë—Ç–∞ –≤ –º–µ—Ç—Ä–∞—Ö
        req.latitude = 0.0
        req.longitude = 0.0
        req.min_pitch = 0.0
        req.yaw = 0.0
        future = self.takeoff_client.call_async(req)
        future.add_done_callback(self.takeoff_response_cb)

    def takeoff_response_cb(self, future):
        try:
            result = future.result()
            if result.success:
                self.get_logger().info('üõ´ –í–∑–ª—ë—Ç —É—Å–ø–µ—à–µ–Ω')
            else:
                self.get_logger().warn(f'‚ö†Ô∏è –í–∑–ª—ë—Ç –æ—Ç–∫–∞–∑: result={result.result}')
        except Exception as e:
            self.get_logger().error(f'‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∑–ª—ë—Ç–∞: {e}')

    def image_callback(self, msg: Image):
        try:
            img = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')
            img = cv2.flip(img, 1)  # –ü–µ—Ä–µ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
            gesture, move_gesture = self.classifier.classify_gesture(img)
            self.get_logger().info(f'–†–∞—Å–ø–æ–∑–Ω–∞–Ω –∂–µ—Å—Ç: {gesture}, Move gesture: {move_gesture}')

            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã Pointer, –µ—Å–ª–∏ –¥–≤–∏–∂–µ–Ω–∏–µ –µ—â—ë –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ
            if self.move_start_time is not None:
                self.get_logger().debug('–î–≤–∏–∂–µ–Ω–∏–µ Pointer –µ—â—ë –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π –∂–µ—Å—Ç')
                return

            if gesture == 'Arm':
                self.disarm_count = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ Disarm
                req = CommandBool.Request()
                req.value = True
                future = self.arm_client.call_async(req)
                future.add_done_callback(self.arm_response_cb)

            elif gesture == 'Disarm':
                self.disarm_count += 1
                self.get_logger().info(f'–û–±–Ω–∞—Ä—É–∂–µ–Ω Disarm, —Å—á—ë—Ç—á–∏–∫: {self.disarm_count}/{self.disarm_threshold}')
                if self.disarm_count >= self.disarm_threshold:
                    req = CommandBool.Request()
                    req.value = False
                    future = self.arm_client.call_async(req)
                    future.add_done_callback(self.disarm_response_cb)
                else:
                    self.current_command = (0.0, 0.0, 0.05, 0.0)  # z=0.05 –¥–ª—è —É–¥–µ—Ä–∂–∞–Ω–∏—è –≤—ã—Å–æ—Ç—ã

            elif gesture == 'Pointer' and move_gesture in self.move_gesture_command:
                self.disarm_count = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ Disarm
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –¥–ª—è —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç–∏
                if move_gesture == self.last_move_gesture:
                    self.move_gesture_count += 1
                else:
                    self.last_move_gesture = move_gesture
                    self.move_gesture_count = 1

                if self.move_gesture_count >= self.move_gesture_threshold:
                    x, y, z, yaw = self.move_gesture_command[move_gesture]
                    self.current_command = (x * self.speed, y * self.speed, z * self.speed, yaw)
                    self.move_start_time = self.get_clock().now()
                    self.move_duration = self.linear_move_duration  # –í—Ä–µ–º—è –¥–ª—è 5 –º
                    self.get_logger().info(f'–ù–∞—á–∞—Ç–æ –¥–≤–∏–∂–µ–Ω–∏–µ Pointer: {move_gesture}, –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {self.move_duration} —Å–µ–∫')
                else:
                    self.get_logger().debug(f'–û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è Pointer: {move_gesture}, —Å—á—ë—Ç—á–∏–∫: {self.move_gesture_count}/{self.move_gesture_threshold}')

            elif gesture in self.gesture_commands:
                self.disarm_count = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ Disarm
                x, y, z, yaw = self.gesture_commands[gesture]
                self.current_command = (x * self.speed, y * self.speed, z * self.speed, yaw)
                twist = TwistStamped()
                twist.header.stamp = self.get_clock().now().to_msg()
                twist.header.frame_id = 'base_link'
                twist.twist.linear.x = x * self.speed
                twist.twist.linear.y = y * self.speed
                twist.twist.linear.z = z * self.speed
                twist.twist.angular.z = yaw
                self.cmd_vel_pub.publish(twist)
                self.get_logger().info(f'–ö–æ–º–∞–Ω–¥–∞: x={x}, y={y}, z={z}, yaw={yaw}')
            
            else:
                self.disarm_count = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ Disarm
                self.get_logger().debug(f'–ñ–µ—Å—Ç –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω –∏–ª–∏ –Ω–µ –ø—Ä–µ–¥—É—Å–º–æ—Ç—Ä–µ–Ω: {gesture}, Move gesture: {move_gesture}')
                self.current_command = (0.0, 0.0, 0.05, 0.0)  # z=0.05 –¥–ª—è —É–¥–µ—Ä–∂–∞–Ω–∏—è –≤—ã—Å–æ—Ç—ã
                self.last_move_gesture = None
                self.move_gesture_count = 0

        except Exception as e:
            self.get_logger().error(f'–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}')

    def destroy_node(self):
        self.classifier.release()
        super().destroy_node()

def main(args=None):
    rclpy.init(args=args)
    node = GestureNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
