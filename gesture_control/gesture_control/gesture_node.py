#!/usr/bin/env python3
import os
import sys
import yaml
import logging
import cv2
import rclpy
from rclpy.node import Node
from cv_bridge import CvBridge
from sensor_msgs.msg import Image
from geometry_msgs.msg import TwistStamped
from mavros_msgs.srv import CommandBool, CommandTOL
from mavros_msgs.msg import State

from addict import Dict
from ament_index_python.packages import get_package_share_directory

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger('gesture_node')

def get_cfg() -> Dict:
    pkg_share = get_package_share_directory('gesture_control')
    config_path = os.path.join(pkg_share, 'params', 'params.yaml')
    with open(config_path, 'rb') as f:
        raw = yaml.load(f, Loader=yaml.FullLoader)
    return Dict(raw['gesture_classifier'])

class GestureNode(Node):
    def __init__(self):
        super().__init__('gesture_node')
        self.cfg = get_cfg()
        
        # –î–æ–±–∞–≤–∏–º –ø—É—Ç—å –∫ —Å–∫—Ä–∏–ø—Ç—É
        script_dir = os.path.dirname(self.cfg.script_path)
        if script_dir not in sys.path:
            sys.path.insert(0, script_dir)

        # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∏ —Å–æ–∑–¥–∞—ë–º –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä
        from app_for_ros2 import GestureClassifier
        self.classifier = GestureClassifier(self.cfg)

        self.bridge = CvBridge()
        self.current_command = (0.0, 0.0, 0.0, 0.0)  # x, y, z, yaw
        self.current_state = State()
        self.offboard_attempts = 0
        self.max_offboard_attempts = 5
        self.disarm_count = 0
        self.disarm_threshold = 15  # –¢—Ä–µ–±—É–µ—Ç—Å—è 15 –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–π Disarm

        # –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥—Ä–æ–Ω–∞
        self.state_sub = self.create_subscription(
            State,
            '/mavros/state',
            self.state_callback,
            10
        )

        self.image_sub = self.create_subscription(
            Image,
            self.cfg.topic.image_input,
            self.image_callback,
            10
        )

        self.cmd_vel_pub = self.create_publisher(
            TwistStamped,
            self.cfg.topic.cmd_vel_output,
            10
        )

        self.arm_client = self.create_client(CommandBool, self.cfg.topic.arming_srv)
        while not self.arm_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info(' –û–∂–∏–¥–∞–Ω–∏–µ MAVROS /cmd/arming...')

        from mavros_msgs.srv import SetMode
        self.set_mode_client = self.create_client(SetMode, '/mavros/set_mode')
        while not self.set_mode_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info(' –û–∂–∏–¥–∞–Ω–∏–µ MAVROS /set_mode...')

        self.takeoff_client = self.create_client(CommandTOL, '/mavros/cmd/takeoff')
        while not self.takeoff_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info(' –û–∂–∏–¥–∞–Ω–∏–µ MAVROS /cmd/takeoff...')

        self.gesture_commands = {
            'Up':       (0.0, 0.0, 1.0, 0.0),
            'Down':     (0.0, 0.0, -1.0, 0.0),
            'Left':     (0.0, 1.0, 0.0, 0.0),
            'Right':    (0.0, -1.0, 0.0, 0.0),
            'Forward':  (1.0, 0.0, 0.0, 0.0),
            'Backward': (-1.0, 0.0, 0.0, 0.0),
        }

        self.speed = self.cfg.get('speed', 0.5)

        # –¢–∞–π–º–µ—Ä –¥–ª—è –∫–æ–º–∞–Ω–¥ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–µ–∂–∏–º–∞
        self.timer = self.create_timer(0.1, self.timer_callback)

        self.get_logger().info(f' GestureNode –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω, –ø–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ {self.cfg.topic.image_input}')

    def state_callback(self, msg):
        self.current_state = msg
        self.get_logger().info(f'–¢–µ–∫—É—â–∏–π —Ä–µ–∂–∏–º: {self.current_state.mode}, Armed: {self.current_state.armed}')

    def set_mode(self, mode_name: str):
        from mavros_msgs.srv import SetMode
        req = SetMode.Request()
        req.custom_mode = mode_name
        future = self.set_mode_client.call_async(req)
        self.get_logger().info(f'–ü–æ–ø—ã—Ç–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ä–µ–∂–∏–º {mode_name}')
        future.add_done_callback(lambda f: self.mode_response_cb(f, mode_name))

    def mode_response_cb(self, future, mode_name):
        try:
            result = future.result()
            if result.mode_sent:
                self.get_logger().info(f'‚úÖ –†–µ–∂–∏–º {mode_name} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω')
                if mode_name == 'OFFBOARD':
                    self.offboard_attempts = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ –ø–æ–ø—ã—Ç–æ–∫
            else:
                self.get_logger().warn(f'‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ä–µ–∂–∏–º {mode_name}')
                if mode_name == 'OFFBOARD' and self.offboard_attempts < self.max_offboard_attempts:
                    self.offboard_attempts += 1
                    self.get_logger().info(f'–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å OFFBOARD ({self.offboard_attempts}/{self.max_offboard_attempts})')
                    self.set_mode('OFFBOARD')
        except Exception as e:
            self.get_logger().error(f'‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ —Ä–µ–∂–∏–º–∞ {mode_name}: {e}')

    def timer_callback(self):
        x, y, z, yaw = self.current_command
        twist = TwistStamped()
        twist.header.stamp = self.get_clock().now().to_msg()
        twist.header.frame_id = 'base_link'
        twist.twist.linear.x = x
        twist.twist.linear.y = y
        twist.twist.linear.z = z
        twist.twist.angular.z = yaw
        self.cmd_vel_pub.publish(twist)
        self.get_logger().debug(f'–ö–æ–º–∞–Ω–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞: x={x}, y={y}, z={z}, yaw={yaw}')

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å–ª–∏ –¥—Ä–æ–Ω –≤ —Ä–µ–∂–∏–º–µ AUTO.LOITER –ø–æ—Å–ª–µ –∞—Ä–º–∏–Ω–≥–∞
        if self.current_state.armed and self.current_state.mode != 'OFFBOARD' and self.offboard_attempts < self.max_offboard_attempts:
            self.get_logger().info(f'–î—Ä–æ–Ω –≤ —Ä–µ–∂–∏–º–µ {self.current_state.mode}, –ø–æ–ø—ã—Ç–∫–∞ –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –≤ OFFBOARD')
            self.set_mode('OFFBOARD')

    def arm_response_cb(self, future):
        try:
            result = future.result()
            if result.success:
                self.get_logger().info('üõ©Ô∏è Arm —É—Å–ø–µ—à–µ–Ω')
                # –ù–∞—á–∏–Ω–∞–µ–º –ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã —Å–∫–æ—Ä–æ—Å—Ç–∏ –¥–ª—è OFFBOARD
                self.current_command = (0.0, 0.0, 0.0, 0.0)  # –ù—É–ª–µ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
                # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–µ–∂–∏–º OFFBOARD
                self.set_mode('OFFBOARD')
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –Ω–∞ –≤–∑–ª—ë—Ç
                self.send_takeoff_command()
            else:
                self.get_logger().warn(f'‚ö†Ô∏è Arm –æ—Ç–∫–∞–∑: result={result.result}')
        except Exception as e:
            self.get_logger().error(f'‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ Arm: {e}')

    def disarm_response_cb(self, future):
        try:
            result = future.result()
            if result.success:
                self.get_logger().info('üõ¨ Disarm —É—Å–ø–µ—à–µ–Ω')
                self.disarm_count = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫
            else:
                self.get_logger().warn(f'‚ö†Ô∏è Disarm –æ—Ç–∫–∞–∑: result={result.result}')
        except Exception as e:
            self.get_logger().error(f'‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ Disarm: {e}')

    def send_takeoff_command(self):
        req = CommandTOL.Request()
        req.altitude = 2.0  # –í—ã—Å–æ—Ç–∞ –≤–∑–ª—ë—Ç–∞ –≤ –º–µ—Ç—Ä–∞—Ö
        req.latitude = 0.0
        req.longitude = 0.0
        req.min_pitch = 0.0
        req.yaw = 0.0
        future = self.takeoff_client.call_async(req)
        future.add_done_callback(self.takeoff_response_cb)

    def takeoff_response_cb(self, future):
        try:
            result = future.result()
            if result.success:
                self.get_logger().info('üõ´ –í–∑–ª—ë—Ç —É—Å–ø–µ—à–µ–Ω')
            else:
                self.get_logger().warn(f'‚ö†Ô∏è –í–∑–ª—ë—Ç –æ—Ç–∫–∞–∑: result={result.result}')
        except Exception as e:
            self.get_logger().error(f'‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∑–ª—ë—Ç–∞: {e}')

    def image_callback(self, msg: Image):
        try:
            img = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')
            img = cv2.flip(img, 1)  # –ü–µ—Ä–µ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
            gesture, move_gesture = self.classifier.classify_gesture(img)
            self.get_logger().info(f' –†–∞—Å–ø–æ–∑–Ω–∞–Ω –∂–µ—Å—Ç: {gesture}')

            if gesture == 'Arm':
                self.disarm_count = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ Disarm
                req = CommandBool.Request()
                req.value = True
                future = self.arm_client.call_async(req)
                future.add_done_callback(self.arm_response_cb)

            elif gesture == 'Disarm':
                self.disarm_count += 1
                self.get_logger().info(f'–û–±–Ω–∞—Ä—É–∂–µ–Ω Disarm, —Å—á—ë—Ç—á–∏–∫: {self.disarm_count}/{self.disarm_threshold}')
                if self.disarm_count >= self.disarm_threshold:
                    req = CommandBool.Request()
                    req.value = False
                    future = self.arm_client.call_async(req)
                    future.add_done_callback(self.disarm_response_cb)
                else:
                    self.current_command = (0.0, 0.0, 0.0, 0.0)  # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ

            elif gesture in self.gesture_commands:
                self.disarm_count = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ Disarm
                x, y, z, yaw = self.gesture_commands[gesture]
                if gesture not in ['Up', 'Down']:
                    z = 0.0
                self.current_command = (x * self.speed, y * self.speed, z * self.speed, yaw)
                twist = TwistStamped()
                twist.header.stamp = self.get_clock().now().to_msg()
                twist.header.frame_id = 'base_link'
                twist.twist.linear.x = x * self.speed
                twist.twist.linear.y = y * self.speed
                twist.twist.linear.z = z * self.speed
                twist.twist.angular.z = yaw
                self.cmd_vel_pub.publish(twist)
                self.get_logger().info(f' –ö–æ–º–∞–Ω–¥–∞: x={x}, y={y}, z={z}, yaw={yaw}')
            else:
                self.disarm_count = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ Disarm
                self.get_logger().debug('–ñ–µ—Å—Ç –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω –∏–ª–∏ –Ω–µ –ø—Ä–µ–¥—É—Å–º–æ—Ç—Ä–µ–Ω')
                self.current_command = (0.0, 0.0, 0.0, 0.0)
        except Exception as e:
            self.get_logger().error(f' –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}')

    def destroy_node(self):
        self.classifier.release()
        super().destroy_node()

def main(args=None):
    rclpy.init(args=args)
    node = GestureNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()